#if no policies correspond to that profile
if(length(data_i) == 0){
eq_lb_profiles[i] = 0
H_profile = H_profile + 1
}
else{
eq_lb_profiles[i] = find_profile_lower_bound(data_i, {{value}})
}
}
eq_lb_profiles =  eq_lb_profiles / num_data
eq_lb_sum = sum(eq_lb_profiles)
#deal with control separately
control_loss = eq_lb_profiles[[1]] + reg
rashomon_profiles[1] = list(RashomonSet(models = list(NA),
losses = control_loss,
pools = list(1),
profiles = list(as.numeric(profiles[1,]))))
for(i in 2:num_profiles){
#extracting relevant things to find rashomon set for this profile
data_i = data_labeled[unlist(D_profile[i]),]
if(nrow(data_i) == 0){
rashomon_profiles[i] = list(RashomonSet(models = list(NA),
losses = 0,
pools = list(0),
profiles = list(as.numeric(profiles[1,]))))
next
}
profile_i = as.numeric(profiles[i,])
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta - (eq_lb_sum - eq_lb_profiles[i])
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
means_i = policy_means(data_i, {{value}})
rashomon_i = find_rashomon_profile(data_i,
value = {{value}},
M = M_i,
R = R_i,
H = H_profile,
reg = reg,
profile = profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = num_data,
theta = theta_k)
invisible(rashomon_i$sort())
rashomon_profiles[i] = list(rashomon_i)
}
R_set = find_feasible_combinations(rashomon_profiles, theta, H, sorted = TRUE)
list(R_set, rashomon_profiles)
}
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
# TODO: Make predictions from this output
# TODO: Test
# TODO: Deal with ids in a smart way
#but otherwise, mostly done
all_losses = c()
for(x in rset[[1]]){
loss = 0
for(i in 1:length(rset[[2]])){
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
loss = loss + loss_i
}
all_losses = c(all_losses, loss)
}
View(rset)
all_losses = c()
for(x in rset[[1]]){
loss = 0
for(i in 1:length(rset[[2]])){
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
loss = loss + loss_i
}
all_losses = c(all_losses, loss)
}
#but otherwise, mostly done
compute_loss <- function(rset){
all_losses = c()
for(x in rset[[1]]){
loss = 0
for(i in 1:length(rset[[2]])){
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
loss = loss + loss_i
}
all_losses = c(all_losses, loss)
}
all_losses
}
compute_loss
compute_loss(rset)
min(compute_loss(rset))
help(ReferenceClasses)
compute_loss
?compute_loss
subset_prof
pol_in_prof
?mutate
#' Find all combinations of indices from the list of arrays S such that sum <= theta
#' @param S List of lists of numbers
#' @param theta Threshold
#' @returns List of combinations of indices, one from each array in S
#' such that their sum is less than or equal to theta
find_feasible_sum_subsets <- function(S,theta){
numsets = length(S)
if(numsets == 0){
return(list())
}
S1 = S[[1]]
S1_feasible_ids = which(S1 <= theta)
if(numsets == 1){
feasible_combs = lapply(S1_feasible_ids, list)
return(feasible_combs)
}
# Since the list is sorted, add the first elements of the remaining sets
# Then use this to check feasibility of indices in S1_feasible_idx
first_element_sum = 0
for(x in S[2:numsets]){
first_element_sum = first_element_sum + x[1]
}
feasible_combs = list()
for(i in S1_feasible_ids){
theta_i = theta - S1[i]
if(first_element_sum > theta_i){
next
}
subproblem_res_i = find_feasible_sum_subsets(S[2:numsets], theta_i)
subproblem_res_i = lapply(subproblem_res_i, function(x) c(i,x))
feasible_combs = append(feasible_combs, subproblem_res_i)
}
feasible_combs
}
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
?aggregate_rashomon_profiles
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
#' by the data.
#' @param reg Regularization parameter that penalizes partitions with more pools
#' @param normalize Whether or not to normalize loss (unsure?)
#' @param lattice_edges Edges of pooling structure
#' @param R A list (or integer) of the number of levels in each arm.
#' @importFrom collections dict
#' @import magrittr
#' @import dplyr
#' @export
#' @returns Loss given pool for the data
compute_loss <- function(data, value, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA, R){
mse = compute_mse_loss(data, {{value}}, M, sigma, policy_list, reg = 1, normalize = normalize, lattice_edges)
reg_loss = compute_penalization_loss(sigma, R, reg)
mse + reg_loss
}
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
# TODO: Make predictions from this output
# TODO: Test
# TODO: Deal with ids in a smart way
#but otherwise, mostly done
compute_loss <- function(rset){
all_losses = c()
for(x in rset[[1]]){
loss = 0
for(i in 1:length(rset[[2]])){
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
loss = loss + loss_i
}
all_losses = c(all_losses, loss)
}
all_losses
}
View(rset)
rm(list = ls())
library(rashomontva)
library(tidyverse)
library(collections)
library(data.table)
#M = 2
#R = c(3,4)
data <- data.frame(arm1 = c(1,1,1,1,1,1,1,1,1,2,2,3,3,3,2,2,2,2,2,2,3,3,3,3,3,3,3),
arm2 = c(1,2,3,1,2,3,1,2,3,1,2,3,1,2,4,1,2,3,1,2,3,4,2,4,1,2,4),
value = runif(27))
sigma <- initialize_sigma(2, c(5,5))
data <- assign_policy_label(data,arm1,arm2)
policy_list <- create_policies_from_data(data, arm1, arm2)
edge_list <- lattice_edges(sigma, policy_list)
M <- policy_means(data, value)
# use as.integer
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
# TODO: Make predictions from this output
# TODO: Test
# TODO: Deal with ids in a smart way
#but otherwise, mostly done
compute_loss <- function(rset){
all_losses = c()
for(x in rset[[1]]){
loss = 0
for(i in 1:length(rset[[2]])){
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
loss = loss + loss_i
}
all_losses = c(all_losses, loss)
}
all_losses
}
View(rset)
View(rset)
rashomontva::RashomonSet
rashomontva::
list()
c()
rset[[2]]
rset[[2]][[1]]
rset[[2]][[2]]
rset[[2]][[1]]$usingMethods
make_rashomon_objects <- function(rset){
rash_models = list()
for(x in rset[[1]]){
rashomon_i = RashomonSet(models = list(),
losses = c(),
pools = list(),
profiles = list())
for(i in 1:length(rset[[2]])){
model_i = rset[[2]][[i]]$models[[x[[i]]]]
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
pools_i = rset[[2]][[i]]$pools[[x[[i]]]]
profiles_i = rset[[2]][[i]]$profiles[[x[[i]]]]
rashomon_i$insert_model(model_i, loss_i, pools_i, profiles_i)
}
rash_models = append(rash_models, rashomon_i)
}
rash_models
}
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
data <- read.csv('output.csv') %>%
rename(arm1 = 'X0',
arm2 = 'X1',
arm3 = 'X2',
id = 'X',
observation = 'Y') %>%
select(-D)
M = 3
R = c(4,3,3)
H = Inf
theta = 13
lamb = 1
rset <- aggregate_rashomon_profiles(data,
arm1,
arm2,
arm3,
M = M,
H = H,
R = R,
reg = lamb,
value = observation,
theta = theta)
# TODO: Make predictions from this output
# TODO: Test
# TODO: Deal with ids in a smart way
#but otherwise, mostly done
compute_loss <- function(rset){
all_losses = c()
for(x in rset[[1]]){
loss = 0
for(i in 1:length(rset[[2]])){
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
loss = loss + loss_i
}
all_losses = c(all_losses, loss)
}
all_losses
}
make_rashomon_objects <- function(rset){
rash_models = list()
for(x in rset[[1]]){
rashomon_i = RashomonSet(models = list(),
losses = c(),
pools = list(),
profiles = list())
for(i in 1:length(rset[[2]])){
model_i = rset[[2]][[i]]$models[[x[[i]]]]
loss_i = rset[[2]][[i]]$losses[[x[[i]]]]
pools_i = rset[[2]][[i]]$pools[[x[[i]]]]
profiles_i = rset[[2]][[i]]$profiles[[x[[i]]]]
rashomon_i$insert_model(model_i, loss_i, pools_i, profiles_i)
}
rash_models = append(rash_models, rashomon_i)
}
rash_models
}
View(rset)
make_rashomon_objects(rset)
R CMD check --as-cran
attachment::att_amend_desc()
install.packages("attachment")
attachment::att_amend_desc()
# Update dependencies in DESCRIPTION
# install.packages('attachment', repos = 'https://thinkr-open.r-universe.dev')
attachment::att_amend_desc()
# Check package coverage
covr::package_coverage()
checkhelper::find_missing_tags()
rashomontva::RashomonSet
rashomontva::RashomonSet$sort()
rashomontva::RashomonSet
?rashomontva::RashomonSet
#' @title Rashomon Set
#' @desc RashomonSet class. This can be used to both form the RashomonSet for a given
#' profile and a single member of the RashomonSet across all profiles.
#' @field models The M X R-2 partition matrices that give the pooling structure for
#' their profile
#' @field losses The losses for each of the models when evaluated on their profile
#' @field pools The number of pools in the each of the models when evaluated on their profile
#' @field profiles The profiles for each of the models.
#' @export RashomonSet
#' @exportClass RashomonSet
RashomonSet <- setRefClass("RashomonSet", fields = list(models = "list",
losses = "numeric",
pools = "list",
profiles = "list"),
methods = list(insert_model = insert_model,
sort = sort))
checkhelper::find_missing_tags()
checkhelper::find_missing_tags()
rm(list = c("RashomonSet"))
checkhelper::find_missing_tags()
spelling::spell_check_package()
devtools::check()
use_mit_license()
use_mit_license()
usethis::use_mit_license()
?mutate
devtools::check()
usethis::use_package(dplyr)
usethis::use_package("dplyr")
usethis::use_package("collections")
devtools::check()
devtools::check()
devtools::check()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::check_win_devel()
devtools::revdep()
install.packages("stylr")
install.packages("styler")
styler:::style_active_pkg()
styler:::style_active_pkg()
styler:::style_active_pkg()
devtools::check()
usethis::use_vignette()
usethis::use_vignette("rashomon_example_vignette")
devtools::check()
devtools::check()
remove.packages("htmltools")
install.packages("htmltools")
devtools::check()
devtools::check()
devtools::check()
