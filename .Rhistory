for(i in 2:num_profiles){
#assign profile labels and extract appropriate subset
profile_i = as.numeric(profiles[i,])
data_i = subset_prof(data_labeled, policy_list, profile_i, 1)
print(data_i)
if(length(data_i) == 0){
next
}
data_profile_ids[data_i$id] <- i
#extracting relevant things to find rashomon set for this profile
means_i = policy_means(data_i, {{value}})
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta
print('cp3')
print(M_i)
print(R_i)
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
rashomon_i = find_rashomon_profile(data_i,
{{value}},
M_i,
R_i,
H_profile,
reg,
profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = 0,
theta = theta_k)
print(rashomon_i)
}
}
#TODO: implement find_profile_lower_bound
#TODO: Fix issue with pool ids
aggregate_rashomon_profiles(data,
arm1,
arm2,
M = 2,
H = Inf,
R = c(4,4),
value = value,
theta = -Inf)
aggregate_rashomon_profiles <- function(data,
...,
M,
H,
R,
value,
theta,
reg = 1,
bruteforce = FALSE
){
num_profiles = 2^M
profiles = expand.grid(replicate(M, 0:1, simplify = FALSE))
#creating policy labels on data as well as list of all policies
data_labeled <- assign_policy_label(data,...)
policy_list <- create_policies_from_data(data_labeled,...)
num_data <- nrow(data_labeled)
data_labeled$id <- 1:num_data
#Maximum number of pools for a profile derived from maximum number of pools
H_profile = H - num_profiles + 1
data_profile_ids = rep(0, num_data)
print('cp2')
#Assign profile ids to each data point
for(i in 2:num_profiles){
#assign profile labels and extract appropriate subset
profile_i = as.numeric(profiles[i,])
data_i = subset_prof(data_labeled, policy_list, profile_i, 1)
print(data_i)
if(length(data_i) == 0){
next
}
data_profile_ids[data_i$id] <- i
#extracting relevant things to find rashomon set for this profile
means_i = policy_means(data_i, {{value}})
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta
print('cp3')
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
print(data_i)
print(policy_list_i_masked)
rashomon_i = find_rashomon_profile(data_i,
{{value}},
M_i,
R_i,
H_profile,
reg,
profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = 0,
theta = theta_k)
print(rashomon_i)
}
}
#TODO: implement find_profile_lower_bound
#TODO: Fix issue with pool ids
aggregate_rashomon_profiles(data,
arm1,
arm2,
M = 2,
H = Inf,
R = c(4,4),
value = value,
theta = -Inf)
create_policies_from_data()
create_policies_from_data
aggregate_rashomon_profiles <- function(data,
...,
M,
H,
R,
value,
theta,
reg = 1,
bruteforce = FALSE
){
num_profiles = 2^M
profiles = expand.grid(replicate(M, 0:1, simplify = FALSE))
#creating policy labels on data as well as list of all policies
data_labeled <- assign_policy_label(data,...)
policy_list <- create_policies_from_data(data_labeled,...)
num_data <- nrow(data_labeled)
data_labeled$id <- 1:num_data
#Maximum number of pools for a profile derived from maximum number of pools
H_profile = H - num_profiles + 1
data_profile_ids = rep(0, num_data)
print('cp2')
#Assign profile ids to each data point
for(i in 2:num_profiles){
#assign profile labels and extract appropriate subset
profile_i = as.numeric(profiles[i,])
data_i = subset_prof(data_labeled, policy_list, profile_i, 1)
print(data_i)
if(length(data_i) == 0){
next
}
data_profile_ids[data_i$id] <- i
#extracting relevant things to find rashomon set for this profile
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta
print('cp3')
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
means_i = policy_means(data_i, {{value}})
print(data_i)
print(policy_list_i_masked)
rashomon_i = find_rashomon_profile(data_i,
{{value}},
M_i,
R_i,
H_profile,
reg,
profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = 0,
theta = theta_k)
print(rashomon_i)
}
}
#TODO: implement find_profile_lower_bound
#TODO: Fix issue with pool ids
aggregate_rashomon_profiles(data,
arm1,
arm2,
M = 2,
H = Inf,
R = c(4,4),
value = value,
theta = -Inf)
aggregate_rashomon_profiles <- function(data,
...,
M,
H,
R,
value,
theta,
reg = 1,
bruteforce = FALSE
){
num_profiles = 2^M
profiles = expand.grid(replicate(M, 0:1, simplify = FALSE))
#creating policy labels on data as well as list of all policies
data_labeled <- assign_policy_label(data,...)
policy_list <- create_policies_from_data(data_labeled,...)
num_data <- nrow(data_labeled)
data_labeled$id <- 1:num_data
#Maximum number of pools for a profile derived from maximum number of pools
H_profile = H - num_profiles + 1
data_profile_ids = rep(0, num_data)
print('cp2')
#Assign profile ids to each data point
for(i in 2:num_profiles){
#assign profile labels and extract appropriate subset
profile_i = as.numeric(profiles[i,])
data_i = subset_prof(data_labeled, policy_list, profile_i, 1)
print(data_i)
if(length(data_i) == 0){
next
}
data_profile_ids[data_i$id] <- i
#extracting relevant things to find rashomon set for this profile
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
means_i = policy_means(data_i, {{value}})
rashomon_i = find_rashomon_profile(data_i,
{{value}},
M_i,
R_i,
H_profile,
reg,
profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = 0,
theta = theta_k)
print(rashomon_i)
}
}
#TODO: implement find_profile_lower_bound
#TODO: Fix issue with pool ids
aggregate_rashomon_profiles(data,
arm1,
arm2,
M = 2,
H = Inf,
R = c(4,4),
value = value,
theta = -Inf)
#| label: main loop
#assumptions about data here:
#data has been assigned policy labels
#we have list of policies from data
#we will filter data for the that fit the profile
#after filtering for policies in profile, pull out labels from policy_list
#this is to use for filtering data
#number in policy_list will correspond to policy_label in data.
find_rashomon_profile <- function(data, value, M,R,H, reg=1,
profile,
policies = c(),
policy_means=c(),
normalize=0,
theta = Inf){
if(max(R) == 2){
sigma = matrix(nrow = M, ncol = 1)
rashomon_set = list(sigma)
return(rashomon_set)
}
sigma = initialize_sigma(M, R)
hasse_edges = lattice_edges(sigma, policies)
print('here')
#creating list for compatibility
if(length(R) == 1){
R = rep(R, M)
}
#defining list, hash tables, and queue
rashomon_set = list()
seen_sigmas = hashtab()
seen_sigmas_sub = hashtab()
queue_sigma = collections::queue(items = NULL)
#pushing initial problems onto queue
for(i in 1:M){
if(!is.na(sigma[i,1])){
queue_sigma$push(list(sigma,i,0))
}
}
count = 0
#main queue loop
while(queue_sigma$size() > 0){
count = count + 1
sigma_list = queue_sigma$pop()
sigma = sigma_list[[1]]
i = sigma_list[[2]]
j = sigma_list[[3]]
sethash(seen_sigmas_sub, sigma_list, 1)
if(num_pools(sigma,R) > H)
next
sigma_1 = sigma
sigma_0 = sigma
sigma_1[i,j] = 1
sigma_0[i,j] = 0
#adding all subproblem variants
for(m in 1:M){
R_m = R[m]
j1 = 1
sigma_1_list = list(sigma_1, m, j1)
#have we seen this subproblem?
seen = gethash(seen_sigmas_sub, sigma_1_list, nomatch = 0)
#if we have seen it, and our cutting index is less than R_m - 2, consider further cuts
while(seen != 0 & j1 <= R_m - 2){
j1 = j1 + 1
sigma_1_list = list(sigma_1,m,j1)
seen = gethash(seen_sigmas_sub, sigma_1_list, nomatch = 0)
}
#if we haven't seen it and cutting is at a vlaid range, add it as a subproblem
if(j1 <= R_m -2 & seen == 0){
queue_sigma$push(sigma_1_list)
sethash(seen_sigmas_sub, sigma_1_list,1)
}
j0 = 1
sigma_0_list = list(sigma_0, m, j0)
seen = gethash(seen_sigmas_sub, sigma_0_list, nomatch = 0)
while(seen != 0 & j0 <= R_m - 2){
j0 = j0 + 1
sigma_0_list = list(sigma_0, m, j0)
seen = gethash(seen_sigmas_sub, sigma_0_list, nomatch = 0)
}
if(j0 <= R_m -2 & seen == 0){
queue_sigma$push(sigma_0_list)
sethash(seen_sigmas_sub, sigma_0_list,1)
}
}
#computing B to check whether more splits is possible
#i had to add this condition... why does apara's code not need it?
if(j != ncol(sigma)){
print('here_2')
B = compute_B(data, {{value}}, i,j, policy_means, sigma, policies, reg = 1, normalize = 0,
lattice_edges = hasse_edges,R)
if(B > theta){
next
}
}
#Check if unsplit pool satisfies Rashomon threshold
if(gethash(seen_sigmas, sigma_1, nomatch = 0) == 0){
sethash(seen_sigmas, sigma_1,1)
Q = compute_loss(data, {{value}}, policy_means, sigma_1, policies, reg = 1, normalize = 0,
lattice_edges = hasse_edges,R)
if(Q <= theta){
rashomon_set = append(rashomon_set, list(sigma_1))
}
}
#Check if split pool satisfies Rashomon threshold
if(gethash(seen_sigmas, sigma_0, nomatch = 0) == 0 & num_pools(sigma_0,R) <= H){
sethash(seen_sigmas, sigma_0,1)
Q = compute_loss(data, {{value}}, policy_means, sigma_0, policies, reg = 1, normalize = 0,
lattice_edges = hasse_edges,R)
if(Q <= theta){
rashomon_set = append(rashomon_set, list(sigma_0))
}
}
sigma_1_list = list(sigma_1, i, j+1)
sigma_0_list = list(sigma_0, i, j+1)
#add child problems
if(j+1 < R[i] - 2){
if(gethash(seen_sigmas_sub, sigma_1_list, nomatch = 0) == 0){
queue_sigma$push(list(sigma_1,i, j + 1))
}
if(gethash(seen_sigmas_sub, sigma_0_list, nomatch = 0) == 0){
queue_sigma$push(list(sigma_0,i, j + 1))
}
}
}
rashomon_set
}
# res <- find_rashomon_profile(data = data,
#                      value = value,
#                      M = 2,
#                      R = c(3,4),
#                      H = Inf,
#                      profile = c(1,1),
#                      policies = policy_list,
#                      policy_means = M)
aggregate_rashomon_profiles <- function(data,
...,
M,
H,
R,
value,
theta,
reg = 1,
bruteforce = FALSE
){
num_profiles = 2^M
profiles = expand.grid(replicate(M, 0:1, simplify = FALSE))
#creating policy labels on data as well as list of all policies
data_labeled <- assign_policy_label(data,...)
policy_list <- create_policies_from_data(data_labeled,...)
num_data <- nrow(data_labeled)
data_labeled$id <- 1:num_data
#Maximum number of pools for a profile derived from maximum number of pools
H_profile = H - num_profiles + 1
data_profile_ids = rep(0, num_data)
print('cp2')
#Assign profile ids to each data point
for(i in 2:num_profiles){
#assign profile labels and extract appropriate subset
profile_i = as.numeric(profiles[i,])
data_i = subset_prof(data_labeled, policy_list, profile_i, 1)
print(data_i)
if(length(data_i) == 0){
next
}
data_profile_ids[data_i$id] <- i
#extracting relevant things to find rashomon set for this profile
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
means_i = policy_means(data_i, {{value}})
rashomon_i = find_rashomon_profile(data_i,
{{value}},
M_i,
R_i,
H_profile,
reg,
profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = 0,
theta = theta_k)
print(rashomon_i)
}
}
#TODO: implement find_profile_lower_bound
#TODO: Fix issue with pool ids
aggregate_rashomon_profiles(data,
arm1,
arm2,
M = 2,
H = Inf,
R = c(4,4),
value = value,
theta = -Inf)
aggregate_rashomon_profiles <- function(data,
...,
M,
H,
R,
value,
theta,
reg = 1,
bruteforce = FALSE
){
num_profiles = 2^M
profiles = expand.grid(replicate(M, 0:1, simplify = FALSE))
#creating policy labels on data as well as list of all policies
data_labeled <- assign_policy_label(data,...)
policy_list <- create_policies_from_data(data_labeled,...)
num_data <- nrow(data_labeled)
data_labeled$id <- 1:num_data
#Maximum number of pools for a profile derived from maximum number of pools
H_profile = H - num_profiles + 1
data_profile_ids = rep(0, num_data)
print('cp2')
#Assign profile ids to each data point
for(i in 2:num_profiles){
#assign profile labels and extract appropriate subset
profile_i = as.numeric(profiles[i,])
data_i = subset_prof(data_labeled, policy_list, profile_i, 1)
print(data_i)
if(length(data_i) == 0){
next
}
data_profile_ids[data_i$id] <- i
#extracting relevant things to find rashomon set for this profile
M_i = sum(profile_i)
R_i = R[as.logical(profile_i)]
#find profile_lower_bound to find theta_k
#lower_bound = compute_mse_loss(data,{{value}},)
theta_k = theta
data_i = assign_policy_label(data_i, ...)
policy_list_i = create_policies_from_data(data_i, ...)
policy_list_i_masked = lapply(policy_list_i, function(x) x[as.logical(profile_i)])
means_i = policy_means(data_i, {{value}})
rashomon_i = find_rashomon_profile(data_i,
{{value}},
M_i,
R_i,
H_profile,
reg,
profile_i,
policies = policy_list_i_masked,
policy_means = means_i,
normalize = 0,
theta = theta_k)
print(rashomon_i)
}
}
#TODO: implement find_profile_lower_bound
#TODO: Fix issue with pool ids
aggregate_rashomon_profiles(data,
arm1,
arm2,
M = 2,
H = Inf,
R = c(4,4),
value = value,
theta = Inf)
