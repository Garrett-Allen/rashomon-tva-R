#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(i in 1:length(pools_data)){
pool_mean_data[i] = fixed_pool_means_dict$get(as.integer(pools_data[i]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
mse
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
sigma[is.na(sigma)]
is.na(sigma)
# TODO: implement num_pools in counter
num_pools <- function(sigma){
if(all(is.na(sigma))){
return(1)
}
return(5)
}
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(i in 1:length(pools_data)){
pool_mean_data[i] = fixed_pool_means_dict$get(as.integer(pools_data[i]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
sigma_fix[i, (j+1):ncol(sigma_fix)] = 1
sigma_fix[is.na(sigma)] = NA
h = num_pools(sigma_fix)
B = mse + reg * h
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(i in 1:length(pools_data)){
pool_mean_data[i] = fixed_pool_means_dict$get(as.integer(pools_data[i]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
sigma_fix[i, (j+1):ncol(sigma_max_split)] = 1
sigma_fix[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(i in 1:length(pools_data)){
pool_mean_data[i] = fixed_pool_means_dict$get(as.integer(pools_data[i]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
sigma[1,2:2]
ncol(sigma)
sigma[1,2]
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(i in 1:length(pools_data)){
pool_mean_data[i] = fixed_pool_means_dict$get(as.integer(pools_data[i]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
print(sigma_max_split)
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
sigma[1,]
sigma[1,1:]
sigma[1,2:]
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(i in 1:length(pools_data)){
pool_mean_data[i] = fixed_pool_means_dict$get(as.integer(pools_data[i]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
print(sigma_max_split)
print((j + 1):ncol(sigma_max_split))
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
sigma[1,2:2] = 1
sigma
sigma[1,2:2] = 0
sigma
sigma[1,2:2] = 1
data <- data.frame(arm1 = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3),
arm2 = c(1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3),
value = runif(27))
#searching rashomon set
data <- assign_policy_label(data,arm1,arm2)
#calculate policy_means
policy_means <- function(data, value, policy_label){
#convert to data.table
data %>%
group_by(policy_label) %>%
summarize(sum = sum({{value}}, na.rm = TRUE),
n = n(),
mean = mean({{value}}),
.groups = "drop",
policy_label = policy_label[1])
}
#assigns poolls to a data structure
pools_to_data <- function(data, pools_dict){
policy_label <- as.integer(dplyr::pull(data,policy_label))
len_data = length(policy_label)
pool_label = numeric(len_data)
for(i in 1:len_data){
pool_label[i] = pools_dict$get(policy_label[i])
}
data$pool = pool_label
data
}
#note: data argument here must be output from pools_to_data
pool_means <- function(data, value, pool){
means <- data %>%
group_by({{pool}}) %>%
summarize(mean_pool = mean({{value}}))
pool_means_dict = collections::dict()
for(i in 1:nrow(means)){
pool_means_dict$set(as.integer(pull(means,{{pool}})[i]), pull(means,mean_pool)[i])
}
pool_means_dict
}
#used for finding B, make maximal number of cuts
partition_sigma <- function(i, j, sigma) {
new_sigma = sigma
new_sigma[i, j:ncol(new_sigma)] = 0
new_sigma[is.na(sigma)] = NA
new_sigma
}
#compute policy means from data that has already been parsed by assign_policy_labels
M <- policy_means(data, value)
M <- pools_to_data(M, cc) #assign pools from policy labels
P <- pool_means(M, mean, pool)
pools_to_data(data, cc)
extract_pools <- function(policies, sigma, lattice_edges = NA){
if(any(is.na(lattice_edges))){
lattice_relations = lattice_edges(sigma, policies)
}
else{
lattice_relations = prune_edges(sigma, lattice_edges, policies)
}
pools = connected_components(length(policies), lattice_relations)
pools
}
# TODO: implement num_pools in counter
num_pools <- function(sigma){
if(all(is.na(sigma))){
return(1)
}
return(5)
}
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
print(sigma_max_split)
print((j + 1):ncol(sigma_max_split))
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
policy_list
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma_max_split, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
B
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_mse_loss <- function(data, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = None){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_mse_loss <- function(data, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = None){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B <- function(data, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
mse = compute_mse_loss(data, M, sigma, policy_list)
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
B
}
compute_B(data, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_mse_loss <- function(data, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = None){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B <- function(data, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
mse = compute_mse_loss(data, M, sigma_max_split, policy_list)
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
B
}
compute_mse_loss <- function(data, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = None){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B(data, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_B <- function(data, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
mse = compute_mse_loss(data, M, sigma_max_split, policy_list, lattice_edges)
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
B
}
compute_mse_loss <- function(data, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = None){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B(data, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_mse_loss <- function(data, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B <- function(data, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
mse = compute_mse_loss(data, M, sigma_max_split, policy_list, lattice_edges)
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
B
}
compute_B(data, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Split maximally across row, starting at point i, j:
sigma_max_split = partition_sigma(i,j,sigma)
mse = compute_mse_loss(data, value, M, sigma_max_split, policy_list, lattice_edges)
#least number of pools
#least bad penalty for complexity
sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
sigma_max_split[is.na(sigma)] = NA
h = num_pools(sigma_max_split)
B = mse + reg * h
B
}
compute_mse_loss <- function(data,value, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
#TODO: implement this
compute_penalization_loss <- function(sigma){
if(all(is.na(sigma))){
return(1)
}
return(5)
}
compute_mse_loss <- function(data,value, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
#Compute pools for new maximal split
pool_dict = extract_pools(policy_list, sigma, lattice_edges)
# assigning pools to policy means so that we can compute pool means
M_pool <- pools_to_data(M, pool_dict)
#dictionary of pool means of type cc:dictionary()
fixed_pool_means_dict = pool_means(M_pool, mean, pool)
#assign pool labels to data and extract pool labels
pools_data = pools_to_data(data,pool_dict)$pool
#vector for storing pool mean for each observation
pool_mean_data <- numeric(length(pools_data))
#assigning pool mean to each observation
for(k in 1:length(pools_data)){
pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
}
y = dplyr::pull(data,{{value}})
mse = (yardstick::rmse_vec(pool_mean_data, y))^2
}
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
