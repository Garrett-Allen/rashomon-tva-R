---
title: "rashomon_package"
author: "garrett-allen"
format: html
editor: visual
---

```{r}
library(rashomontva)
library(tidyverse)
library(collections)
library(data.table)
```

#todo add examples

```{r}

data <- assign_policy_label(data,arm1,arm2)
policy_list <- rashomontva::create_policies_from_data(data, arm1, arm2)
sigma <- matrix(c(1,1,1,1), ncol = 2, nrow = 2)

edge_list <- lattice_edges(sigma, policy_list)

new_sigma <- matrix(c(0,1,1,1), ncol = 2, nrow = 2)
pruned_edge_list <- prune_edges(new_sigma,edge_list,policy_list)

cc <- connected_components(length(pruned_edge_list),pruned_edge_list,policy_list)

edge_list

str(cc$get(as.integer(1)))
# use as.integer

```

```{r}
data <- data.frame(arm1 = c(1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3),
                   arm2 = c(1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3),
                   value = runif(27))
#searching rashomon set
data <- assign_policy_label(data,arm1,arm2)

#calculate policy_means
policy_means <- function(data, value, policy_label){
  
  #convert to data.table
  data %>% 
    group_by(policy_label) %>% 
    summarize(sum = sum({{value}}, na.rm = TRUE),
              n = n(),
              mean = mean({{value}}),
              .groups = "drop",
              policy_label = policy_label[1])
}

#assigns poolls to a data structure
pools_to_data <- function(data, pools_dict){
  
  policy_label <- as.integer(dplyr::pull(data,policy_label))
  
  len_data = length(policy_label)
  
  pool_label = numeric(len_data)

  for(i in 1:len_data){
      pool_label[i] = pools_dict$get(policy_label[i])
  }
  
  data$pool = pool_label
  data
    
}


#note: data argument here must be output from pools_to_data
pool_means <- function(data, value, pool){
  
  means <- data %>% 
    group_by({{pool}}) %>% 
    summarize(mean_pool = mean({{value}}))
  

  pool_means_dict = collections::dict()
  for(i in 1:nrow(means)){
    pool_means_dict$set(as.integer(pull(means,{{pool}})[i]), pull(means,mean_pool)[i]) 
  }
  
  pool_means_dict
}


#used for finding B, make maximal number of cuts
partition_sigma <- function(i, j, sigma) {
  
  new_sigma = sigma
  new_sigma[i, j:ncol(new_sigma)] = 0
  new_sigma[is.na(sigma)] = NA
  
  new_sigma
}

#compute policy means from data that has already been parsed by assign_policy_labels
M <- policy_means(data, value) 

M <- pools_to_data(M, cc) #assign pools from policy labels

P <- pool_means(M, mean, pool)

pools_to_data(data, cc)


extract_pools <- function(policies, sigma, lattice_edges = NA){
  
  if(any(is.na(lattice_edges))){
    lattice_relations = lattice_edges(sigma, policies)
  }
  else{
    lattice_relations = prune_edges(sigma, lattice_edges, policies)
  }
  
  
  pools = connected_components(length(policies), lattice_relations)
  
  pools
  
  
}

# TODO: implement num_pools in counter


compute_B <- function(data, value, i,j, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
  
  #Split maximally across row, starting at point i, j:
  sigma_max_split = partition_sigma(i,j,sigma)
  
  mse = compute_mse_loss(data, value, M, sigma_max_split, policy_list, lattice_edges)
  
  #least number of pools
  #least bad penalty for complexity
  sigma_max_split[i, (j+1):ncol(sigma_max_split)] = 1
  sigma_max_split[is.na(sigma)] = NA
  
  h = compute_penalization_loss(sigma)
  
  B = mse + reg * h
  
  B
  
}

compute_mse_loss <- function(data,value, M, sigma, policy_list, reg = 1, normalize = 0, lattice_edges = NA){
  
   #Compute pools for new maximal split
  pool_dict = extract_pools(policy_list, sigma, lattice_edges)
  
  # assigning pools to policy means so that we can compute pool means
  M_pool <- pools_to_data(M, pool_dict)
  
  #dictionary of pool means of type cc:dictionary()
  fixed_pool_means_dict = pool_means(M_pool, mean, pool)
  
  #assign pool labels to data and extract pool labels
  pools_data = pools_to_data(data,pool_dict)$pool 
  
  #vector for storing pool mean for each observation 
  pool_mean_data <- numeric(length(pools_data))
  
  #assigning pool mean to each observation
  for(k in 1:length(pools_data)){
    pool_mean_data[k] = fixed_pool_means_dict$get(as.integer(pools_data[k]))
  }
  
  y = dplyr::pull(data,{{value}})
  
  mse = (yardstick::rmse_vec(pool_mean_data, y))^2
  
}

#TODO: implement this
compute_penalization_loss <- function(sigma){
  if(all(is.na(sigma))){
    return(1)
  }
  
  return(5)
}

#TODO: make compute_loss function mse + h *reg

# TODO: document all this


# calculates sum of all k-products efficiently using dynamic programming/recursion
#input arr must be vector of type numeric
sum_product_k <- function(arr) {
  # Length of the input array
  n <- length(arr)
  
  # Initialize cache and k_sum arrays
  cache <- numeric(n + 1)
  k_sum <- numeric(n + 1)
  
  k_sum[1] <- 1
  
  # Case k = 1
  for (i in 1:n) {
    cache[i + 1] <- arr[i]
    k_sum[2] <- k_sum[2] + arr[i]
  }
  
  # Case k = 2 through n
  for (k in 3:(n + 1)) {
    prev_sum <- k_sum[k - 1]
    
    for (i in 1:n) {
      prev_sum <- prev_sum - cache[i + 1]
      cache[i + 1] <- arr[i] * prev_sum
    }
    
    k_sum[k] <- sum(cache)
  }
  
  return(k_sum)
}

num_pools_fixed_r <- function(sigma, R){
  m = nrow(sigma)
  z = rowSums(sigma)
  print(z)
  z_sums = sum_product_k(z)
  H = 0
  print(z_sums)
  for(i in 1:(m + 1)){
    print(i)
    sign = (-1) ^ (i-1)
    H = H + sign * z_sums[i] * ((R - 1))^(m - i +1)
  }
  H
}
8 - 4 * 3 + 2*2 
num_pools_fixed_r(new_sigma, 3)
compute_B(data, value, 1,1, M, new_sigma, policy_list, lattice_edges = pruned_edge_list)
policy_list
```

```{r}
# TODO: FIX that current 
```
